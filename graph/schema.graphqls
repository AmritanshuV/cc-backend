type Job {
  Id:               ID!             # Database ID, unique
  JobId:            Int!            # ID given to the job by the cluster scheduler
  User:             String!         # Username
  Project:          String!         # Project
  Cluster:          String!         # Name of the cluster this job was running on
  StartTime:        Time!           # RFC3339 formated string
  Duration:         Int!            # For running jobs, the time it has already run
  NumNodes:         Int!            # Number of nodes this job was running on
  NumHWThreads:     Int!
  NumAcc:           Int!
  SMT:              Int!
  Exclusive:        Int!
  Partition:        String!
  ArrayJobId:       Int!
  MonitoringStatus: Int!
  State:            JobState!       # State of the job
  Tags:             [JobTag!]!      # List of tags this job has
  Resources:        [JobResource!]! # List of hosts/hwthreads/gpus/...

  # Will be null for running jobs.
  LoadAvg:     Float
  MemUsedMax:  Float
  FlopsAnyAvg: Float
  MemBwAvg:    Float
  NetBwAvg:    Float
  FileBwAvg:   Float
}

type JobResource {
  Hostname: String!
  HWThreads: [Int!]
  Accelerators: [Accelerator!]
}

type Accelerator {
  Id: String!
  Type: String!
  Model: String!
}

# TODO: Extend by more possible states?
enum JobState {
  running
  completed
  failed
  canceled
  stopped
  timeout
}

type JobTag {
  Id:      ID!     # Database ID, unique
  TagType: String! # Type
  TagName: String! # Name
}

type Cluster {
  ClusterID:       String!
  ProcessorType:   String!
  SocketsPerNode:  Int!
  CoresPerSocket:  Int!
  ThreadsPerCore:  Int!
  FlopRateScalar:  Int!
  FlopRateSimd:    Int!
  MemoryBandwidth: Int!
  MetricConfig:    [MetricConfig!]!
  FilterRanges:    FilterRanges!
}

type MetricConfig {
  Name:     String!
  Unit:     String!
  Timestep: Int!
  Peak:     Int!
  Normal:   Int!
  Caution:  Int!
  Alert:    Int!
  Scope:    String!
}

type JobMetric {
  Unit:     String!
  Scope:    JobMetricScope!
  Timestep: Int!
  Series:   [JobMetricSeries!]!
}

type JobMetricSeries {
  Hostname:   String!
  Id:         Int
  Statistics: JobMetricStatistics
  Data:       [NullableFloat!]!
}

type JobMetricStatistics {
  Avg: Float!
  Min: Float!
  Max: Float!
}

type JobMetricWithName {
  name:   String!
  metric: JobMetric!
}

type MetricFootprints {
  name: String!
  footprints: [NullableFloat!]!
}

enum Aggregate { USER, PROJECT, CLUSTER }

type NodeMetric {
  name: String!
  data: [NullableFloat!]!
}

type NodeMetrics {
  id:      String!
  metrics: [NodeMetric!]!
}

type Query {
  clusters:     [Cluster!]!   # List of all clusters
  tags:         [JobTag!]!    # List of all tags

  job(id: ID!): Job
  jobMetrics(id: ID!, metrics: [String!]): [JobMetricWithName!]!
  jobsFootprints(filter: [JobFilter!], metrics: [String!]!): [MetricFootprints]!

  jobs(filter: [JobFilter!], page: PageRequest, order: OrderByInput): JobResultList!
  jobsStatistics(filter: [JobFilter!], groupBy: Aggregate): [JobsStatistics!]!

  rooflineHeatmap(filter: [JobFilter!]!, rows: Int!, cols: Int!, minX: Float!, minY: Float!, maxX: Float!, maxY: Float!): [[Float!]!]!

  nodeMetrics(cluster: ID!, nodes: [String!], metrics: [String!], from: Time!, to: Time!): [NodeMetrics!]!
}

type Mutation {
  createTag(type: String!, name: String!): JobTag!
  deleteTag(id: ID!): ID!
  addTagsToJob(job: ID!, tagIds: [ID!]!): [JobTag!]!
  removeTagsFromJob(job: ID!, tagIds: [ID!]!): [JobTag!]!

  updateConfiguration(name: String!, value: String!): String
}

type IntRangeOutput {
  from: Int!
  to:   Int!
}

type TimeRangeOutput {
  from: Time!
  to:   Time!
}

type FilterRanges {
  duration:  IntRangeOutput!
  numNodes:  IntRangeOutput!
  startTime: TimeRangeOutput!
}

input JobFilter {
  tags:        [ID!]
  jobId:       StringInput
  user:        StringInput
  project:     StringInput
  cluster:     StringInput
  duration:    IntRange
  numNodes:    IntRange
  startTime:   TimeRange
  jobState:    [JobState!]
  flopsAnyAvg: FloatRange
  memBwAvg:    FloatRange
  loadAvg:     FloatRange
  memUsedMax:  FloatRange
}

input OrderByInput {
  field: String!
  order: SortDirectionEnum! = ASC
}

enum SortDirectionEnum {
  DESC
  ASC
}

input StringInput {
  eq:         String
  contains:   String
  startsWith: String
  endsWith:   String
}

input IntRange {
  from: Int!
  to:   Int!
}

input FloatRange {
  from: Float!
  to:   Float!
}

input TimeRange {
  from: Time
  to:   Time
}

type JobResultList {
  items:  [Job!]!
  offset: Int
  limit:  Int
  count:  Int
}

type HistoPoint {
  count: Int!
  value: Int!
}

type JobsStatistics  {
  id:             ID!            # If `groupBy` was used, ID of the user/project/cluster
  totalJobs:      Int!           # Number of jobs that matched
  shortJobs:      Int!           # Number of jobs with a duration of less than 2 minutes
  totalWalltime:  Int!           # Sum of the duration of all matched jobs in hours
  totalCoreHours: Int!           # Sum of the core hours of all matched jobs
  histWalltime:   [HistoPoint!]! # value: hour, count: number of jobs with a rounded duration of value
  histNumNodes:   [HistoPoint!]! # value: number of nodes, count: number of jobs with that number of nodes
}

input PageRequest {
  itemsPerPage: Int!
  page:         Int!
}

scalar Time
scalar NullableFloat
scalar JobMetricScope
