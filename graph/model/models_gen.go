// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type AddJobInput struct {
	JobID     string    `json:"jobId"`
	UserID    string    `json:"userId"`
	ProjectID string    `json:"projectId"`
	ClusterID string    `json:"clusterId"`
	StartTime time.Time `json:"startTime"`
	Duration  int       `json:"duration"`
	NumNodes  int       `json:"numNodes"`
}

type FloatRange struct {
	From float64 `json:"from"`
	To   float64 `json:"to"`
}

type HistoPoint struct {
	Count int `json:"count"`
	Value int `json:"value"`
}

type IntRange struct {
	From int `json:"from"`
	To   int `json:"to"`
}

type JobData struct {
	LoadOne            *JobMetric `json:"load_one"`
	MemUsed            *JobMetric `json:"mem_used"`
	MemBw              *JobMetric `json:"mem_bw"`
	FlopsAny           *JobMetric `json:"flops_any"`
	FlopsDp            *JobMetric `json:"flops_dp"`
	FlopsSp            *JobMetric `json:"flops_sp"`
	CpiAvg             *JobMetric `json:"cpi_avg"`
	ClockSpeed         *JobMetric `json:"clock_speed"`
	TotalPower         *JobMetric `json:"total_power"`
	TrafficReadEth     *JobMetric `json:"traffic_read_eth"`
	TrafficWriteEth    *JobMetric `json:"traffic_write_eth"`
	TrafficReadLustre  *JobMetric `json:"traffic_read_lustre"`
	TrafficWriteLustre *JobMetric `json:"traffic_write_lustre"`
	RegReadLustre      *JobMetric `json:"reg_read_lustre"`
	RegWriteLustre     *JobMetric `json:"reg_write_lustre"`
	InodesLustre       *JobMetric `json:"inodes_lustre"`
	PkgRateReadIb      *JobMetric `json:"pkg_rate_read_ib"`
	PkgRateWriteIb     *JobMetric `json:"pkg_rate_write_ib"`
	CongestionIb       *JobMetric `json:"congestion_ib"`
}

type JobFilter struct {
	JobID      *StringInput `json:"jobId"`
	UserID     *StringInput `json:"userId"`
	ProjectID  *StringInput `json:"projectId"`
	ClusterID  *StringInput `json:"clusterId"`
	Duration   *IntRange    `json:"duration"`
	NumNodes   *IntRange    `json:"numNodes"`
	StartTime  *TimeRange   `json:"startTime"`
	HasProfile *bool        `json:"hasProfile"`
}

type JobFilterList struct {
	List []*JobFilter `json:"list"`
}

type JobMetric struct {
	Unit     string             `json:"unit"`
	Scope    JobMetricScope     `json:"scope"`
	Timestep int                `json:"timestep"`
	Series   []*JobMetricSeries `json:"series"`
}

type JobMetricSeries struct {
	NodeID     string               `json:"node_id"`
	Statistics *JobMetricStatistics `json:"statistics"`
	Data       []*float64           `json:"data"`
}

type JobMetricStatistics struct {
	Avg float64 `json:"avg"`
	Min float64 `json:"min"`
	Max float64 `json:"max"`
}

type JobMetricWithName struct {
	Name   string     `json:"name"`
	Metric *JobMetric `json:"metric"`
}

type JobResultList struct {
	Items  []*Job `json:"items"`
	Offset *int   `json:"offset"`
	Limit  *int   `json:"limit"`
	Count  *int   `json:"count"`
}

type JobsStatistics struct {
	TotalJobs      int           `json:"totalJobs"`
	ShortJobs      int           `json:"shortJobs"`
	TotalWalltime  int           `json:"totalWalltime"`
	TotalCoreHours int           `json:"totalCoreHours"`
	HistWalltime   []*HistoPoint `json:"histWalltime"`
	HistNumNodes   []*HistoPoint `json:"histNumNodes"`
}

type OrderByInput struct {
	Field string             `json:"field"`
	Order *SortDirectionEnum `json:"order"`
}

type PageRequest struct {
	ItemsPerPage *int `json:"itemsPerPage"`
	Page         *int `json:"page"`
}

type StartJobInput struct {
	JobID     string    `json:"jobId"`
	UserID    string    `json:"userId"`
	ProjectID string    `json:"projectId"`
	ClusterID string    `json:"clusterId"`
	StartTime time.Time `json:"startTime"`
	NumNodes  int       `json:"numNodes"`
}

type StopJobInput struct {
	StopTime time.Time `json:"stopTime"`
}

type StringInput struct {
	Eq         *string `json:"eq"`
	Contains   *string `json:"contains"`
	StartsWith *string `json:"startsWith"`
	EndsWith   *string `json:"endsWith"`
}

type TimeRange struct {
	From time.Time `json:"from"`
	To   time.Time `json:"to"`
}

type JobMetricScope string

const (
	JobMetricScopeNode   JobMetricScope = "node"
	JobMetricScopeCPU    JobMetricScope = "cpu"
	JobMetricScopeSocket JobMetricScope = "socket"
)

var AllJobMetricScope = []JobMetricScope{
	JobMetricScopeNode,
	JobMetricScopeCPU,
	JobMetricScopeSocket,
}

func (e JobMetricScope) IsValid() bool {
	switch e {
	case JobMetricScopeNode, JobMetricScopeCPU, JobMetricScopeSocket:
		return true
	}
	return false
}

func (e JobMetricScope) String() string {
	return string(e)
}

func (e *JobMetricScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobMetricScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobMetricScope", str)
	}
	return nil
}

func (e JobMetricScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortDirectionEnum string

const (
	SortDirectionEnumDesc SortDirectionEnum = "DESC"
	SortDirectionEnumAsc  SortDirectionEnum = "ASC"
)

var AllSortDirectionEnum = []SortDirectionEnum{
	SortDirectionEnumDesc,
	SortDirectionEnumAsc,
}

func (e SortDirectionEnum) IsValid() bool {
	switch e {
	case SortDirectionEnumDesc, SortDirectionEnumAsc:
		return true
	}
	return false
}

func (e SortDirectionEnum) String() string {
	return string(e)
}

func (e *SortDirectionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirectionEnum", str)
	}
	return nil
}

func (e SortDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
